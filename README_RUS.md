# Day 01 - Go Boot camp

## Содержание

1. [Глава I](#chapter-i) \
    1.1. [Основные правила](#general-rules)
2. [Глава II](#chapter-ii) \
    2.1. [Правила дня](#rules-of-the-day)
3. [Глава III](#chapter-iii) \
    3.1. [Введение](#intro)
4. [Глава IV](#chapter-iv) \
    4.1. [Упражнение 00: Чтение](#exercise-00-reading)
5. [Глава V](#chapter-v) \
    5.1. [Упражнение 01: Оценка ущерба](#exercise-01-assessing-damage)
6. [Глава VI](#chapter-vi) \
    6.1. [Упражнение 02: Афтепати](#exercise-02-afterparty)


<h2 id="chapter-i" >Глава I</h2>
<h2 id="general-rules" >Основные правила</h2>

<h2 id="chapter-i" >Глава I</h2>
<h2 id="general-rules" >Основные правила</h2>

* Твоя программа не должна закрываться неожиданно (выдавая ошибку при корректном вводе). Если это произойдет, твой проект будет считаться неработаспособным и получит 0 во время оценки.
* Мы рекомендуем тебе писать тесты для твоего проекта, даже если если они и не оцениваются. Это даст тебе возможность легко тестировать твою работу и работу твоих пиров. Ты убедишься что тесты очень полезны, во время защиты. Во время защиты ты свободен использовать свои тесты и/или тесты пира которого ты проверяешь.
* Отправляй свою работу в нужный git репозиторий. Работа будет оцениваться только из git репозитория.
* Если твой код использует сторонние зависимости, следует использовать [Go Modules](https://go.dev/blog/using-go-modules) для управления ими.

<h2 id="chapter-ii" >Глава II</h2>
<h2 id="rules-of-the-day" >Правила дня</h2>

* Пиши код только в `*.go` файлах и (в случае стронних зависимостей) `go.mod` + `go.sum`
* Твой код для этого задания должен собираться с использовния простого `go build`

<h2 id="chapter-iii" >Глава III</h2>
<h2 id="intro" >Введение</h2>

В мире программирования много популярных форматов данных и в го в частности. Но это очень похоже что ты встретишься с одним из них на своем пути - XML или JSON. Множество и множество API которые используют JSON и/или XML для представления структурированной информации.

И...иногда некоторые пекари используют их для хранения рецептов. Так старая известная пекарня в Вилларибе использовала только старый добрый XML для хранения списка рецептов тортов. Ес мы возьмем и посмотрим на кусочек этой базы данных это будет выглядеть типа такого:

```xml
<recipes>
    <cake>
        <name>Red Velvet Strawberry Cake</name>
        <stovetime>40 min</stovetime>
        <ingredients>
            <item>
                <itemname>Flour</itemname>
                <itemcount>3</itemcount>
                <itemunit>cups</itemunit>
            </item>
            <item>
                <itemname>Vanilla extract</itemname>
                <itemcount>1.5</itemcount>
                <itemunit>tablespoons</itemunit>
            </item>
            <item>
                <itemname>Strawberries</itemname>
                <itemcount>7</itemcount>
                <itemunit></itemunit> <!-- itemunit может быть пустым  -->
            </item>
            <item>
                <itemname>Cinnamon</itemname>
                <itemcount>1</itemcount>
                <itemunit>pieces</itemunit>
            </item>
            <!-- Здесь может быть больше ингридиентов  -->
        </ingredients>
    </cake>
    <cake>
        <name>Blueberry Muffin Cake</name>
        <stovetime>30 min</stovetime>
        <ingredients>
            <item>
                <itemname>Baking powder</itemname>
                <itemcount>3</itemcount>
                <itemunit>teaspoons</itemunit>
            </item>
            <item>
                <itemname>Brown sugar</itemname>
                <itemcount>0.5</itemcount>
                <itemunit>cup</itemunit>
            </item>
            <item>
                <itemname>Blueberries</itemname>
                <itemcount>1</itemcount>
                <itemunit>cup</itemunit>
            </item>
            <!-- Здесь может быть больше ингридиентов  -->
        </ingredients>
    </cake>
    <!-- Здесь может быть больше тортов  -->
</recipes>
```

Жизнь была прекрасна и проста пока владелец пекарни не заметил что в соседней деревне Виллабажо сейчас живет грязный предатель который решил украсть его рецепты. Для того что бы это провернуть он использовал другой тип хранения данных и это утаило его от правосудия! 

```json
{
  "cake": [
    {
      "name": "Red Velvet Strawberry Cake",
      "time": "45 min",
      "ingredients": [
        {
          "ingredient_name": "Flour",
          "ingredient_count": "2",
          "ingredient_unit": "mugs"
        },
        {
          "ingredient_name": "Strawberries",
          "ingredient_count": "8"  // ingredient_unit больше тут нет!
        },
        {
          "ingredient_name": "Coffee Beans",
          "ingredient_count": "2.5",
          "ingredient_unit": "tablespoons"
        },
        {
          "ingredient_name": "Cinnamon",
          "ingredient_count": "1"
        }
      ]
    },
    {
      "name": "Moonshine Muffin",
      "time": "30 min",
      "ingredients": [
        {
          "ingredient_name": "Brown sugar",
          "ingredient_count": "1",
          "ingredient_unit": "mug"
        },
        {
          "ingredient_name": "Blueberries",
          "ingredient_count": "1",
          "ingredient_unit": "mug"
        }
      ]
    }
  ]
}
```

Он не мог не заметить что вор не только своровал его рецепты, но и также он изменил некоторые из них. Некоторые ингридиенты отсутствуют, количества изменены, части переименованы. Так что он подготовил свою месть!


<h2 id="chapter-iv" >Глава IV</h2>
<h3 id="ex00">Упражнение 00: Чтение</h3>

Перво-наперво, он стал изучать как читать из базы данных. Владелец уже имел CLI, так он решил что чтение файла будет простым, так обе из них будут работать (файлы могут различаться по расширению для простоты) 

```sh
./readDB -f original_database.xml
./readDB -f stolen_database.json
```

Не только это, он также решил что чтение обеих файлов не будет сложным производить через один интерфейс, который будет назван `DBReader`. Это означает что чтение различных форматов реализовано через разные *имплементации* одного интерфейса `DBReader`, который будет выдавать одни и те же типы объектов в результате, без разницы прочтен файл был из оригинальной базы данных или украденной. Верно, его идея это выбирать подходящую имплементацию на основе расширения файла.

И тебе нужно будет помочь ему с этим. Подумай какие типы объектов в этой базе данных и как их можно представить в коде. Затем напиши интерфейс `DBReader` и две реализации его, одну для чтения JSON, другую для чтения XML. Обе из них должны возвращать объект одного типа в качестве результата. 

Для проверки что это идея работает сделай код для вывода на экран JSON версии базы данных XML и наоборот (лат. `vice versa`). Оба формата XML и JSON должны иметь отступ полей в 4 пробела (так называемый приятный вывод "pretty-printing").

<h2 id="chapter-v" >Глава V</h2>
<h3 id="ex01">Exercise 01: Оценка ущерба</h3>

Оки, так теперь владелец решил сравнить базы данных. Ты увидел что сворованная база данных имеет измененные версии одних и тех же рецептов, имеется в виду что они похожие в таких случах:

1) Новый торт добавлен или старый один удален.
2) Время приготовления различное для одного и того же торта
3) Новые ингридиенты добавлены или удалены из одного же торта.
4) Количество частей для одного и того же ингридиента было поменяно.
5) Изменилась сама единица измерения ингредиента
6) Единица ингридиента была потеряна или добавлена

Быстрым просмотром базы данных, владелец так же уведомил что никто не удосужился переименовать торты или ингридиенты (возможно, только добавлены некоторые новые), так что ты можешь предположить что имена в обеих базах данных одинаковые.

Твое приложение должно работать как-то так:

```sh
./compareDB --old original_database.xml --new stolen_database.json
```

Оно должно работать с обеими форматами (JSON и XML) для орининальной И новой базой данных, переиспользуя код из Упражнения 00.

Вывод должен выглядить таким образом (некоторые случаи объяснены ниже):

```txt
ADDED cake "Moonshine Muffin"
REMOVED cake "Blueberry Muffin Cake"
CHANGED cooking time for cake "Red Velvet Strawberry Cake" - "45 min" instead of "40 min"
ADDED ingredient "Coffee beans" for cake  "Red Velvet Strawberry Cake"
REMOVED ingredient "Vanilla extract" for cake  "Red Velvet Strawberry Cake"
CHANGED unit for ingredient "Flour" for cake  "Red Velvet Strawberry Cake" - "mugs" instead of "cups"
CHANGED unit count for ingredient "Strawberries" for cake  "Red Velvet Strawberry Cake" - "8" instead of "7"
REMOVED unit "pieces" for ingredient "Cinnamon" for cake  "Red Velvet Strawberry Cake"
```

<h2 id="chapter-vi" >Глава VI</h2>
<h3 id="ex02">Exercise 02: Афтепати</h3>

Копая вглубь базы данных, владелец пекарни Виллариба внезапно осознал - этот парень просто сокровище. Некоторые рецепты были улучшены значительно в сравнении со старой версией и эти новые идеи действительно творческие. Он пробился в Виллабажои нашел парня, который как сперва казалось украл его самое драгоценное наследие.

...В этот же вечер в таверне два старых пекаря обнимались, выпивали и смеялись так сильно что это было слышно в обеих деревнях. Они стали лучшими друзьями за последние несколько частов, каждый из них был по-настоящему счастлив что наконец-то нашел человека кто мог бы болтать всю ночь о тортах. Также открылось что парень не украл базу данных, он просто пытался угадать вкус и пытался импровизировать немного.

После всего этого беспорядка они оба согласились использовать твой код, но попросили сделать последнее задание для них. Они приличино впечатлены тем как ты управился с сравнением между базами данных и теперь они также попросили тебя сделать похожую штуку со их сервером хранения разервных копий, так никакой пакерь не столкнется с никакаими техническими проблемами в будущем.

Так, твоя программа должна делать две(2) резервных копии. 

```sh
./compareFS --old snapshot1.txt --new snapshot2.txt
```

Они обе являются обычными текстовыми файлами, несортированными и каждый из них включает путь до файла, например:

```txt
/etc/stove/config.xml
/Users/baker/recipes/database.xml
/Users/baker/recipes/database_version3.yaml
/var/log/orders.log
/Users/baker/pokemon.avi
```

Твой инструмент должен выводить очень похожую штуку на предыдущий код (без CHANGED(изменено) случая конечно)

```txt
ADDED /etc/systemd/system/very_important/stash_location.jpg
REMOVED /var/log/browser_history.txt
```

Здесь есть еще одна проблемка правда - файлы могут быть по-настоящему большими и ты не можешь разом выгружать их в RAM (оперативную память) (они не поместятся). Тут есть два возможных пути для того чтобы это обойти, как-то сжимать их в память в памяти, или просто читать один и затем избегать чтение другого.
**Побочная заметка**: это довольно популярный вопрос на собеседовании.


